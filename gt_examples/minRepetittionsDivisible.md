## Step 1. 문제 이해하기

### 문제 인식
여기 문제는 숫자 \( n \)을 반복해서 이어붙여 만든 숫자가 주어진 \( k \)로 나누어 떨어지는 최소 반복 횟수를 찾는 것입니다. \( n \)과 \( k \)는 다음과 같은 특징을 가집니다:

- **Input 값의 특징:**
  - \( n \): 1 이상 10 이하의 자연수
  - \( k \): 1 이상 10,000 이하의 자연수

- **Output 값의 특징:**
  - \( n \)을 반복해서 이어붙인 숫자가 \( k \)로 나누어 떨어지는 최소 반복 횟수를 반환합니다.
  - 반복 횟수 내에 나누어 떨어지지 않으면 -1을 반환합니다.

### 제약 조건 인식
- 주어진 숫자의 크기를 고려하여 시간 복잡도와 효율성을 생각해야 합니다.
- 최대 반복 횟수는 \( k \)까지 고려할 수 있습니다.

### 예상할 수 있는 오류 파악
- 반복 횟수가 \( k \)까지 증가해도 나누어 떨어지지 않는 경우
- 숫자가 커지면서 발생할 수 있는 계산 오류

## Step 2. 접근 방법

### 문제 분석 및 효율성 검토
- \( n \)을 반복해서 문자열로 만들고 큰 숫자를 직접 계산하는 것은 비효율적일 수 있습니다.
- 따라서, 각 반복마다 나머지를 추적하여 효율적으로 해결해야 합니다.

### 문제의 핵심 요소 및 알고리즘 선택
- 나머지를 사용하여 현재 숫자가 \( k \)로 나누어 떨어지는지 확인합니다.
- 나머지를 저장하여 무한 루프를 방지합니다.

### 알고리즘 로직 설명
- \( n \)을 문자열로 변환하여 각 자리수를 순회합니다.
- 현재까지의 나머지를 계산하고, 나머지가 0이 되면 반복 횟수를 반환합니다.
- 이전에 나온 나머지를 Set 자료구조에 저장하여 중복 여부를 확인합니다.

## Step 3. 코드 설계(의사코드)

1. \( n \)을 문자열로 변환하여 `nStr`에 저장합니다.
2. `remainder`와 `count` 변수를 0으로 초기화합니다.
3. `remainderSet`이라는 Set을 초기화합니다.
4. 반복문을 사용하여 다음을 수행합니다:
   - `count`를 1 증가시킵니다.
   - `nStr`의 각 자리 숫자를 순회하며 `remainder`를 업데이트합니다.
   - `remainder`가 0이면 `count`를 반환합니다.
   - `remainder`가 이미 `remainderSet`에 있으면 -1을 반환합니다.
   - `remainderSet`에 `remainder`를 추가합니다.
5. 반복문이 종료되면 -1을 반환합니다.

## Step 4. 코드 구현

## Step 5. 문제풀이 형상화(예시)

### 문제 인식
이 문제는 \( n \)을 반복해서 이어붙여 만든 숫자가 주어진 \( k \)로 나누어 떨어지는 최소 반복 횟수를 찾는 것입니다.

### 제약 조건 인식
최대 반복 횟수는 \( k \)까지 고려해야 하며, \( n \)과 \( k \)는 자연수입니다.

### 문제 분석 및 효율성 검토
완전 탐색은 비효율적이므로, 나머지를 사용하여 효율적으로 문제를 해결합니다.

### 문제의 핵심 요소 및 알고리즘 선택
나머지를 추적하고, 중복된 나머지가 나오면 반복을 종료합니다.

### 알고리즘 로직 설명
1. `n`을 문자열로 변환하여 `nStr`에 저장합니다.
2. `remainder`와 `count` 변수를 초기화합니다.
3. `remainderSet`을 초기화합니다.
4. 반복문을 사용하여 `nStr`의 각 자리 숫자를 순회하며 `remainder`를 업데이트합니다.
5. `remainder`가 0이면 반복 횟수를 반환하고, 중복된 나머지가 나오면 -1을 반환합니다.

### 예외 사례 검토
예를 들어, \( n = 22 \)이고 \( k = 9 \)일 때:
1. 첫 번째 반복: 22 % 9 = 4
2. 두 번째 반복: 422 % 9 = 7
3. 세 번째 반복: 7222 % 9 = 1
4. 네 번째 반복: 17222 % 9 = 3
5. 다섯 번째 반복: 317222 % 9 = 6
6. 여섯 번째 반복: 6317222 % 9 = 0

따라서, 9번 반복하면 222222222가 9로 나누어 떨어지므로 반복 횟수는 9입니다. 이 접근 방식은 효율적이며, 문제의 요구사항을 충족시킵니다.